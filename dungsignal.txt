//+------------------------------------------------------------------+
//|                                                       TMA+CG.mq4 |
//|                                                           mladen |
//| arrowse coded acording to idea presented by dzung                |
//+------------------------------------------------------------------+
#property copyright "dzung"
#property link      "braverynew@gmail.com"

#property description "edited by dzungle"
#property description "no repaint"

#property indicator_chart_window
#property indicator_buffers 17
#property indicator_color1   clrNONE
#property indicator_color2   clrNONE
#property indicator_color3   clrNONE
#property indicator_color4   clrNONE
#property indicator_color5   clrNONE
#property indicator_color6   clrNONE
#property indicator_color7   clrNONE
#property indicator_color8   clrNONE
#property indicator_color9   clrNONE
#property indicator_color10  clrNONE
#property indicator_color11  clrNONE
#property indicator_color12  clrNONE
#property indicator_color13  clrNONE
#property indicator_color14  clrNONE
#property indicator_color15  clrNONE
#property indicator_color16  clrLime
#property indicator_color17  clrRed
#property indicator_style1     STYLE_DOT
#property indicator_style2     STYLE_DOT
#property indicator_style3     STYLE_DOT
#property indicator_style4     STYLE_DOT
#property indicator_style5     STYLE_DOT
#property indicator_style6     STYLE_DOT
#property indicator_style7     STYLE_DOT
#property indicator_style8     STYLE_DOT
#property indicator_style9     STYLE_DOT
#property indicator_style10    STYLE_DOT
#property indicator_style11    STYLE_DOT
#property indicator_style12    STYLE_SOLID
#property indicator_style13    STYLE_SOLID
#property indicator_style14    STYLE_SOLID
#property indicator_style15    STYLE_SOLID
#property  indicator_width1 1
#property  indicator_width2 1
#property  indicator_width3 1
#property  indicator_width4 1
#property  indicator_width5 1
#property  indicator_width6 1
#property  indicator_width7 1
#property  indicator_width8 1
#property  indicator_width9 1
#property  indicator_width10 1
#property  indicator_width11 1
#property  indicator_width12 1
#property  indicator_width13 1
#property  indicator_width14 2
#property  indicator_width15 2
#property  indicator_width16 2
#property  indicator_width17 2
// Danh sách tài khoản hợp lệ
int allowedAccounts[] = {14638776, 87654321};
/*
enum enPrices
{
   pr_close,      // Close
   pr_open,       // Open
   pr_high,       // High
   pr_low,        // Low
   pr_median,     // Median
   pr_typical,    // Typical
   pr_weighted,   // Weighted
   pr_average,    // Average (high+low+open+close)/4
   pr_medianb,    // Average median body (open+close)/2
   pr_tbiased,    // Trend biased price
   pr_tbiased2,   // Trend biased (extreme) price
   pr_hl,         // High/Low
   pr_oc,         // Open/Close
   pr_haclose,    // Heiken ashi close
   pr_haopen ,    // Heiken ashi open
   pr_hahigh,     // Heiken ashi high
   pr_halow,      // Heiken ashi low
   pr_hamedian,   // Heiken ashi median
   pr_hatypical,  // Heiken ashi typical
   pr_haweighted, // Heiken ashi weighted
   pr_haaverage,  // Heiken ashi average
   pr_hamedianb,  // Heiken ashi median body
   pr_hatbiased,  // Heiken ashi trend biased price
   pr_hatbiased2, // Heiken ashi trend biased (extreme) price
   pr_hahl,       // Heiken ashi High/Low
   pr_haoc        // Heiken ashi Open/Close
};
*/
//extern string note1               = "M1=1; M5=5; M15=15; M30=30";
//extern string note2               = "H1=60, H4=240, D1=1440, W1=10080, MN1=43200";
//extern string note3               = "input a number in the TimeFrame tab such as 30, 60, etc...";
extern string TimeFrame           = "current time frame";
//extern ENUM_TIMEFRAMES TimeFrame       = PERIOD_CURRENT;
extern int    HalfLength          = 56;
//extern enPrices           AppliedPrice     = pr_close;         // Price to use
extern int    AppliedPrice        = PRICE_WEIGHTED;
extern double BandsDeviations1    = 2.0;
extern double BandsDeviations2    = 2.236;
extern double BandsDeviations3    = 2.5;
extern double BandsDeviations4    = 2.618;
extern double BandsDeviations5    = 3.0;
extern double BandsDeviations6    = 3.236;
extern double BandsDeviations7    = 3.5;
extern bool   DrawArrows          = true;
extern int    UpArrowSymbolCode   = 233;
extern int    DownArrowSymbolCode = 234;
extern bool   alertsOn            = false;
extern bool   alertsOnCurrent     = false;
extern bool   alertsOnHighLow     = false;
extern bool   Interpolate         = true;
//#define _mtfCall(_buff,_ind) iCustom(NULL,TimeFrame,indicatorFileName,PERIOD_CURRENT,HalfLength,AppliedPrice, BandsDeviations1,BandsDeviations2,BandsDeviations3,BandsDeviations4,BandsDeviations5,BandsDeviations6,BandsDeviations7, DrawArrows, UpArrowSymbolCode, DownArrowSymbolCode, alertsOn, alertsOnCurrent, alertsOnHighLow,_buff,_ind);

bool   alertsMessage   = false;
bool   alertsSound     = false;
bool   alertsEmail     = false;

double tmBuffer[], upBuffer1[], dnBuffer1[], upBuffer2[], dnBuffer2[], upBuffer3[], dnBuffer3[], 
upBuffer4[], dnBuffer4[], upBuffer5[], dnBuffer5[], upBuffer6[], dnBuffer6[], upBuffer7[], dnBuffer7[], 
wuBuffer[], wdBuffer[], upArrow[], dnArrow[], prices[];

string IndicatorFileName;
bool   calculatingTma = false;
bool   returningBars  = false;
int    timeFrame;
// Hàm kiểm tra tài khoản
bool IsAccountAllowed() {
    for (int i = 0; i < ArraySize(allowedAccounts); i++) {
        if (AccountNumber() == allowedAccounts[i]) {
            return true;
        }
    }
    return false;
}
//-------------------------------------------------------------------
int OnInit()
{
    if (!IsAccountAllowed()) {
        Alert("Khong dung duoc chi bao nay nhe. Hay lien he voi Mr Dung");
        return (INIT_FAILED); // Dừng khởi tạo nếu không được phép
    }
//  timeFrame         = fmax(TimeFrame,_Period);
   timeFrame  = stringToTimeFrame(TimeFrame);
   HalfLength = MathMax(HalfLength,1);
   IndicatorBuffers(19);
         SetIndexBuffer(0,tmBuffer);  SetIndexDrawBegin(0,HalfLength); SetIndexLabel(0, "TMA(" + timeFrame + ") Middle Line");
         SetIndexBuffer(1,upBuffer1);  SetIndexDrawBegin(1,HalfLength); SetIndexLabel(1, "TMA(" + timeFrame + ") Upper Line");
         SetIndexBuffer(2,dnBuffer1);  SetIndexDrawBegin(2,HalfLength); SetIndexLabel(2, "TMA(" + timeFrame + ") Lower Line");
         SetIndexBuffer(3,upBuffer2);  SetIndexDrawBegin(3,HalfLength); SetIndexLabel(3, "TMA(" + timeFrame + ") Upper Line");
         SetIndexBuffer(4,dnBuffer2);  SetIndexDrawBegin(4,HalfLength); SetIndexLabel(4, "TMA(" + timeFrame + ") Lower Line");
         SetIndexBuffer(5,upBuffer3);  SetIndexDrawBegin(5,HalfLength); SetIndexLabel(5, "TMA(" + timeFrame + ") Upper Line");
         SetIndexBuffer(6,dnBuffer3);  SetIndexDrawBegin(6,HalfLength); SetIndexLabel(6, "TMA(" + timeFrame + ") Lower Line");
         SetIndexBuffer(7,upBuffer4);  SetIndexDrawBegin(7,HalfLength); SetIndexLabel(7, "TMA(" + timeFrame + ") Upper Line");
         SetIndexBuffer(8,dnBuffer4);  SetIndexDrawBegin(8,HalfLength); SetIndexLabel(8, "TMA(" + timeFrame + ") Lower Line");
         SetIndexBuffer(9,upBuffer5);  SetIndexDrawBegin(9,HalfLength); SetIndexLabel(9, "TMA(" + timeFrame + ") Upper Line");
         SetIndexBuffer(10,dnBuffer5);  SetIndexDrawBegin(10,HalfLength); SetIndexLabel(10, "TMA(" + timeFrame + ") Lower Line");
         SetIndexBuffer(11,upBuffer6);  SetIndexDrawBegin(11,HalfLength); SetIndexLabel(11, "TMA(" + timeFrame + ") Upper Line");
         SetIndexBuffer(12,dnBuffer6);  SetIndexDrawBegin(12,HalfLength); SetIndexLabel(12, "TMA(" + timeFrame + ") Lower Line");
         SetIndexBuffer(13,upBuffer7);  SetIndexDrawBegin(13,HalfLength); SetIndexLabel(13, "TMA(" + timeFrame + ") Upper Band");
         SetIndexBuffer(14,dnBuffer7);  SetIndexDrawBegin(14,HalfLength); SetIndexLabel(14, "TMA(" + timeFrame + ") Lower Band");
         if (DrawArrows)
            {
             SetIndexBuffer(15,dnArrow);   SetIndexStyle(15,DRAW_ARROW); SetIndexArrow(15,UpArrowSymbolCode);   SetIndexLabel(15, "TMA(" + timeFrame + ") LONG");  
             SetIndexBuffer(16,upArrow);   SetIndexStyle(16,DRAW_ARROW); SetIndexArrow(16,DownArrowSymbolCode);   SetIndexLabel(16, "TMA(" + timeFrame + ") SHORT");  
            }
         SetIndexBuffer(17,wuBuffer);
         SetIndexBuffer(18,wdBuffer);

         if (TimeFrame=="calculateTma")  { calculatingTma=true; return(0); }
         if (TimeFrame=="returnBars")    { returningBars=true;  return(0); }

   
   IndicatorFileName = WindowExpertName();
   return(0);
}
//-------------------------------------------------------------------
int deinit() { return(0); }
//-------------------------------------------------------------------
int start()
{
   int counted_bars=IndicatorCounted();
   int i,limit;

   if(counted_bars<0) return(-1);
   if(counted_bars>0) counted_bars--;
           limit=MathMin(Bars-1,Bars-counted_bars+HalfLength);

           if (returningBars)  { tmBuffer[0] = limit; return(0); }
           if (calculatingTma) { calculateTma(limit); return(0); }
           if (timeFrame > Period()) limit = MathMax(limit,MathMin(Bars-1,iCustom(NULL,timeFrame,IndicatorFileName,"returnBars",0,0)*timeFrame/Period()));

   if(limit<Bars-20) limit=1;
 	for(i = limit; i >= 0; i--)
   {
   
      int      shift1 = iBarShift(NULL,timeFrame,Time[i]);
      datetime time1  = iTime    (NULL,timeFrame,shift1);
      
         tmBuffer[i] = iCustom(NULL,timeFrame,IndicatorFileName,"calculateTma",HalfLength,AppliedPrice,BandsDeviations1,0,shift1);
         upBuffer1[i] = iCustom(NULL,timeFrame,IndicatorFileName,"calculateTma",HalfLength,AppliedPrice,BandsDeviations1,1,shift1);
         dnBuffer1[i] = iCustom(NULL,timeFrame,IndicatorFileName,"calculateTma",HalfLength,AppliedPrice,BandsDeviations1,2,shift1);
         upBuffer2[i] = iCustom(NULL,timeFrame,IndicatorFileName,"calculateTma",HalfLength,AppliedPrice,BandsDeviations2,1,shift1);
         dnBuffer2[i] = iCustom(NULL,timeFrame,IndicatorFileName,"calculateTma",HalfLength,AppliedPrice,BandsDeviations2,2,shift1);
         upBuffer3[i] = iCustom(NULL,timeFrame,IndicatorFileName,"calculateTma",HalfLength,AppliedPrice,BandsDeviations3,1,shift1);
         dnBuffer3[i] = iCustom(NULL,timeFrame,IndicatorFileName,"calculateTma",HalfLength,AppliedPrice,BandsDeviations3,2,shift1);
         upBuffer4[i] = iCustom(NULL,timeFrame,IndicatorFileName,"calculateTma",HalfLength,AppliedPrice,BandsDeviations4,1,shift1);
         dnBuffer4[i] = iCustom(NULL,timeFrame,IndicatorFileName,"calculateTma",HalfLength,AppliedPrice,BandsDeviations4,2,shift1);
         upBuffer5[i] = iCustom(NULL,timeFrame,IndicatorFileName,"calculateTma",HalfLength,AppliedPrice,BandsDeviations5,1,shift1);
         dnBuffer5[i] = iCustom(NULL,timeFrame,IndicatorFileName,"calculateTma",HalfLength,AppliedPrice,BandsDeviations5,2,shift1);
         upBuffer6[i] = iCustom(NULL,timeFrame,IndicatorFileName,"calculateTma",HalfLength,AppliedPrice,BandsDeviations6,1,shift1);
         dnBuffer6[i] = iCustom(NULL,timeFrame,IndicatorFileName,"calculateTma",HalfLength,AppliedPrice,BandsDeviations6,2,shift1);
         upBuffer7[i] = iCustom(NULL,timeFrame,IndicatorFileName,"calculateTma",HalfLength,AppliedPrice,BandsDeviations7,1,shift1);
         dnBuffer7[i] = iCustom(NULL,timeFrame,IndicatorFileName,"calculateTma",HalfLength,AppliedPrice,BandsDeviations7,2,shift1);

         if (DrawArrows)
            {
             upArrow[i] = EMPTY_VALUE;
             dnArrow[i] = EMPTY_VALUE;            
             if (High[i+1]>upBuffer1[i+1] && Close[i+1]>Open[i+1] && Close[i]<Open[i]) upArrow[i] = High[i]+iATR(NULL,0,20,i);
             if ( Low[i+1]<dnBuffer1[i+1] && Close[i+1]<Open[i+1] && Close[i]>Open[i]) dnArrow[i] = High[i]-iATR(NULL,0,20,i);
            }
         if (timeFrame <= Period() || shift1==iBarShift(NULL,timeFrame,Time[i-1])) continue;
         if (!Interpolate) continue;

         for(int n = 1; i+n < Bars && Time[i+n] >= time1; n++) continue;
         double factor = 1.0 / n;
         for(int k = 1; k < n; k++)
            {
               tmBuffer[i+k] = k*factor*tmBuffer[i+n] + (1.0-k*factor)*tmBuffer[i];
               upBuffer1[i+k] = k*factor*upBuffer1[i+n] + (1.0-k*factor)*upBuffer1[i];
               dnBuffer1[i+k] = k*factor*dnBuffer1[i+n] + (1.0-k*factor)*dnBuffer1[i];
            }               
   }
   
   if (alertsOn)
   {
      if (alertsOnCurrent)
            int forBar = 0;
      else      forBar = 1;
      if (alertsOnHighLow)       
      {
         if (High[forBar] > upBuffer1[forBar] && High[forBar+1] < upBuffer1[forBar+1]) doAlert("high penetrated upper bar");
         if (Low[forBar]  < dnBuffer1[forBar] && Low[forBar+1]  > dnBuffer1[forBar+1]) doAlert("low penetrated lower bar");
      }
      else
      {
         if (Close[forBar] > upBuffer1[forBar] && Close[forBar+1] < upBuffer1[forBar+1]) doAlert("close penetrated upper bar");
         if (Close[forBar] < dnBuffer1[forBar] && Close[forBar+1] > dnBuffer1[forBar+1]) doAlert("close penetrated lower bar");
      }
   } 

   return(0);
}
//-------------------------------------------------------------------
void calculateTma(int limit)
{
   int i,j,k;
   double FullLength = 2.0*HalfLength+1.0;
   
   for (i=limit; i>=0; i--)
   {
      double sum  = (HalfLength+1)*iMA(NULL,0,1,0,MODE_SMA,AppliedPrice,i);
      double sumw = (HalfLength+1);
      for(j=1, k=HalfLength; j<=HalfLength; j++, k--)
      {
         sum  += k*iMA(NULL,0,1,0,MODE_SMA,AppliedPrice,i+j);
         sumw += k;

         if (j<=i)
         {
            sum  += k*iMA(NULL,0,1,0,MODE_SMA,AppliedPrice,i-j);
            sumw += k;
         }
      }
      tmBuffer[i] = sum/sumw;
            
         double diff = iMA(NULL,0,1,0,MODE_SMA,AppliedPrice,i)-tmBuffer[i];
         if (i> (Bars-HalfLength-1)) continue;
         if (i==(Bars-HalfLength-1))
         {
            upBuffer1[i] = tmBuffer[i];
            dnBuffer1[i] = tmBuffer[i];
            if (diff>=0)
               {
                  wuBuffer[i] = MathPow(diff,2);
                  wdBuffer[i] = 0;
               }
            else
               {               
                  wdBuffer[i] = MathPow(diff,2);
                  wuBuffer[i] = 0;
               }                  
            continue;
         }
         
         if(diff>=0)
            {
               wuBuffer[i] = (wuBuffer[i+1]*(FullLength-1)+MathPow(diff,2))/FullLength;
               wdBuffer[i] =  wdBuffer[i+1]*(FullLength-1)/FullLength;
            }
         else
            {
               wdBuffer[i] = (wdBuffer[i+1]*(FullLength-1)+MathPow(diff,2))/FullLength;
               wuBuffer[i] =  wuBuffer[i+1]*(FullLength-1)/FullLength;
            }
         upBuffer1[i] = tmBuffer[i] + BandsDeviations1*MathSqrt(wuBuffer[i]);
         dnBuffer1[i] = tmBuffer[i] - BandsDeviations1*MathSqrt(wdBuffer[i]);
   }
}
//-------------------------------------------------------------------
void doAlert(string doWhat)
{
   static string   previousAlert="";
   static datetime previousTime;
   string message;
   
   if (previousAlert!=doWhat || previousTime!=Time[0]) 
   {
      previousAlert = doWhat;
      previousTime  = Time[0];

      message= StringConcatenate(Symbol()," at ",TimeToStr(TimeLocal(),TIME_SECONDS)," THA : ",doWhat);
         if (alertsMessage) Alert(message);
         if (alertsEmail)   SendMail(StringConcatenate(Symbol(),"TMA "),message);
         if (alertsSound)   PlaySound("alert2.wav");
    }
}
//-------------------------------------------------------------------
/*
string sTfTable[] = {"M1","M5","M15","M30","H1","H4","D1","W1","MN"};
int    iTfTable[] = {1,5,15,30,60,240,1440,10080,43200};

string stringToTimeFrame2(int tf)
{
   for (int i=ArraySize(iTfTable)-1; i>=0; i--) 
         if (tf==iTfTable[i]) return(sTfTable[i]);
                              return("");
}
*/
//-------------------------------------------------------------------
int stringToTimeFrame(string tfs)
{
   for(int l = StringLen(tfs)-1; l >= 0; l--)
   {
      int tchar = StringGetChar(tfs,l);
          if((tchar > 96 && tchar < 123) || (tchar > 223 && tchar < 256))
               tfs = StringSetChar(tfs, 1, tchar - 32);
          else 
              if(tchar > -33 && tchar < 0)
                  tfs = StringSetChar(tfs, 1, tchar + 224);
   }
   int tf=0;
         if (tfs=="M1" || tfs=="1")     tf=PERIOD_M1;
         if (tfs=="M5" || tfs=="5")     tf=PERIOD_M5;
         if (tfs=="M15"|| tfs=="15")    tf=PERIOD_M15;
         if (tfs=="M30"|| tfs=="30")    tf=PERIOD_M30;
         if (tfs=="H1" || tfs=="60")    tf=PERIOD_H1;
         if (tfs=="H4" || tfs=="240")   tf=PERIOD_H4;
         if (tfs=="D1" || tfs=="1440")  tf=PERIOD_D1;
         if (tfs=="W1" || tfs=="10080") tf=PERIOD_W1;
         if (tfs=="MN" || tfs=="43200") tf=PERIOD_MN1;
         if (tf==0 || tf<Period())      tf=Period();
   return(tf);
} 
//-------------------------------------------------------------------
/*
#define _priceInstances     1
#define _priceInstancesSize 4
double workHa[][_priceInstances*_priceInstancesSize];
double getPrice(int price, const double& open[], const double& close[], const double& high[], const double& low[], int i, int instanceNo=0)
{
  if (price>=pr_haclose)
   {
      if (ArrayRange(workHa,0)!= Bars) ArrayResize(workHa,Bars); int r = Bars-i-1; instanceNo*=_priceInstancesSize;
                 
         double haOpen;
         if (r>0)
                haOpen  = (workHa[r-1][instanceNo+2] + workHa[r-1][instanceNo+3])/2.0;
         else   haOpen  = (open[i]+close[i])/2;
         double haClose = (open[i] + high[i] + low[i] + close[i]) / 4.0;
         double haHigh  = MathMax(high[i], MathMax(haOpen,haClose));
         double haLow   = MathMin(low[i] , MathMin(haOpen,haClose));

         if(haOpen  <haClose) { workHa[r][instanceNo+0] = haLow;  workHa[r][instanceNo+1] = haHigh; } 
         else                 { workHa[r][instanceNo+0] = haHigh; workHa[r][instanceNo+1] = haLow;  } 
                                workHa[r][instanceNo+2] = haOpen;
                                workHa[r][instanceNo+3] = haClose;
         
         switch (price)
         {
            case pr_haclose:     return(haClose);
            case pr_haopen:      return(haOpen);
            case pr_hahigh:      return(haHigh);
            case pr_halow:       return(haLow);
            case pr_hamedian:    return((haHigh+haLow)/2.0);
            case pr_hamedianb:   return((haOpen+haClose)/2.0);
            case pr_hatypical:   return((haHigh+haLow+haClose)/3.0);
            case pr_haweighted:  return((haHigh+haLow+haClose+haClose)/4.0);
            case pr_haaverage:   return((haHigh+haLow+haClose+haOpen)/4.0);
            case pr_hatbiased:
               if (haClose>haOpen)
                     return((haHigh+haClose)/2.0);
               else  return((haLow+haClose)/2.0);        
            case pr_hatbiased2:
               if (haClose>haOpen)  return(haHigh);
               if (haClose<haOpen)  return(haLow);
                                    return(haClose);        
         }
   }
   
   switch (price)
   {
      case pr_close:     return(close[i]);
      case pr_open:      return(open[i]);
      case pr_high:      return(high[i]);
      case pr_low:       return(low[i]);
      case pr_median:    return((high[i]+low[i])/2.0);
      case pr_medianb:   return((open[i]+close[i])/2.0);
      case pr_typical:   return((high[i]+low[i]+close[i])/3.0);
      case pr_weighted:  return((high[i]+low[i]+close[i]+close[i])/4.0);
      case pr_average:   return((high[i]+low[i]+close[i]+open[i])/4.0);
      case pr_tbiased:   
               if (close[i]>open[i])
                     return((high[i]+close[i])/2.0);
               else  return((low[i]+close[i])/2.0);        
      case pr_tbiased2:   
               if (close[i]>open[i]) return(high[i]);
               if (close[i]<open[i]) return(low[i]);
                                     return(close[i]);        
   }                                     
//-------------------------------------------------------------------
*/
